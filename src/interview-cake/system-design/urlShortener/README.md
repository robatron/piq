# Design a URL shortener

You know, like bit.ly.

Let's call it ca.ke!

Step 1 is to scope the project. System design questions like this are usually intentionally left open-ended, so you have to ask some questions and make some decisions about exactly what you're building to get on the same page as your interviewer.

So, what are we building? What features might we need?

https://www.interviewcake.com/question/javascript/url-shortener?course=fc1&section=system-design

## What are we building?

We are building a service which can take a long URL and return a short URL, and can redirect a short URL to a previously-stored long URL

## What features might we need?

-   An HTTP API (Web interface can come later.)
-   Open authentication for now. (We can add auth later.)
-   Add only, no modify or delete. (We can add later.)
-   Links should not expire
    -   If we wanted to expire links, we could either expire some time after creation, or expire some time after last access
        -   If we expire after creation, we'll save space, but could delete heavily-used links
        -   If we expire after last access, we'll use more space, but could also delete links in intranets or printed docs (Embedding URLs in print are a common use case for short links)
-   Short slugs should be auto generated unless custom slug set by user. (B/c that's a common, expected feature in other URL shortening services.)
-   No analytics for now. (Can add later.)

## Design goals

### What are optimizing for?

My answer:

-   MVP over features: Smallest possible product initially so we can launch and receive feedback quickly
-   User experience over space: Frustrate users as little as possible
-   Space over speed: Doesn't need to be particularly fast since users interact with it

Their answer:

-   Should be able to store lots of links b/c not expiring them
-   URLs should be as short as possible (since that's main purpose of product)
-   Following short URL should be fast, but storing can take longer
-   Should be resilient to load spikes since a link could "go viral"

## Data model

Flat map of slugs -> destination links

`Link`

-   `slug` - Slug of the short URL, generated user-chosen
-   `destination` - Original link

## Technical design

Sketch or draft of the technical design.

### Endpoints

A since a user should be able to perform two primary actions, there should be the following endpoints. The endpoint should also be versioned, e.g., /api/v1/

`POST /`

-   **Description:** Save a long link under a slug. The slug is auto generated by default, or can be supplied along with the long link.
-   **Request data (JSON):** The long link as the destination, and an optional slug
-   **Responses:**
    -   200 if saved successfully. Returns with the generated short slug, or echos the one supplied with the response if there was one.
    -   400 for malformed request data
    -   409 if the supplied slug already exists
    -   500 for service runtime errors
    -   501 (not implemented) for any method besides POST (GET, PUT, PATCH, DELETE, etc)

`GET /$SLUG`

-   **Description:** Retrieve and redirect to the long link associated with the slug.
-   **Responses:**
    -   301 redirect with long link if successful
    -   404 if slug is not found
    -   501 for service runtime errors

### Creating a short link

Pseudocode for handling a "create link" request.

```js
const createShortlink = (request) => {
    if (request.method !== 'POST') {
        return response(501, 'HTTP method not implemented');
    }

    const { slug, destination } = request.data;
    const finalSlug = slug ? slug : generateSlug();

    DB.insertLink(finalSlug, destination);

    const respBody = JSON.stringify({ slug: finalSlug });

    return response(200, respBody);
};
```

We'll need to define how `generateSlug()` works.

-   What characters should we use?
-   How do we handle collisions?

(We'll address this later.)

### Following a short link

Pseudocode for handling a "short -> long link" request.

```js
const getDestination = (request) => {
    if (request.method !== 'GET') {
        return response(501, 'HTTP method not implemented');
    }

    const destination = DB.fetchDestination(request.slug);

    return response(301, destination);
};
```

### Short link generation

How will we generate a new short link when one is not supplied?

_My answer:_

-   Allowed characters should be alphanumeric [A-Za-z0-9] for user experience
    -   Possible characters: 26 + 26 + 10 = 62
-   6 digits to start
    -   There are about 2B websites, 200k active
    -   62 ^ 6 = 56.8B => 28.4x more => or 28.4 pages each
-   Generate randomly
-   Check for collisions (which should be fast), and regen if there is one

_Their answer:_

Instead of making a reasonable guess, brainstorming issues, then revising, **brainstorm goals and design around them**.

**Goal:** slugs should be as short as possible while allowing for as many slugs as possible!

How many possible slugs? `c` unique characters ^ `n` number of characters. More unique characters = more possible slugs while keeping length the same.

What characters should we allow? What are the constraints?

-   Slugs should be easy to type on a keyboard
-   Characters should be allowed in URL
    -   Can look up
    -   Don't use URL-reserved chars like `?` or `#`
    -   Don't use path delims like `/`
    -   Domains aren't case-sensitive, but paths are
    -   We should also consider disallowing certain ambiguous chars like 0 and O (Bring up as a potential issue for later.)
    -   Also consider adding valid special typeable chars as allowed for user-defined slugs, e.g., !$^\*().

Let's use `A-Z`, `a-z`, `0-9` for generated slugs which gives us 62 unique chars.

How many unique slugs should we accommodate? Let's say 100k per minute on a busy day. Thats `100k * 60 * 24 = 144M` per day `* 365 = 52.6B` per year. How many years feels like "almost forever" (since we're not expiring any)? How about 100? => 5.3T. That seems like more than enough, but depends on our initial estimate.

How short can we make our slug to accommodate `5.3T`? `62^x = 5.3T => x = 7.1`. Almost `5.3T`, but good enough since our estimate was high.

We can check other shortening products to see if other products agree. Bit.ly does!

In case we run out, we can always add another char. 7 chars => 5.3T, 8 chars => 218.3T ! Huge difference.

### Generating random slug

Pseudocode for generating a random slug:

```js
const generateRandSlug = (charCount = 7, allowedChars = ALLOWED_CHARS) => {
    const slug = '';
    for (let i = 0; i < charCount; i++) {
        slug += chooseRandChar(allowedChars);
    }
    return slug;
};
```

How do we make sure its unique? Can either:

1. **Regen until no collisions** - Not a good choice b/c the collisions will increase as the DB fills up which will result in slower and slower
2. **Generate slugs such that no collisions will happen** - We can make it sequential via base conversion, i.e., have it act as an odometer.

### Generating slugs with base conversion

Pseudocode for incrementing slug:

```js
let curSlugId = 0;

const generateNewSlug() {
    const newId = curSlugId++;
    return baseConversion(newId, base62alphabet);
}
```

Where and how will we store `curSlugId`? We'll consider that later. We should also verify the generated slug isn't taken by someone's custom slug.

### Choosing a database

Relational or NoSQL? Relational better for complex _relationships_, NoSQL faster/better for key-value. URL shortener does not have complex relationships, so NoSQL should do for now.

(It would be good to add an abstraction layer, like an ORM, so we can swap out the database later if needed.)

How do we make sure reads are fast? Make sure primary keys are designed well. Make the key the slug, the main thing we'll be querying. In-memory caching can also help make it faster. Different DBs have different caching features.

Caching discussions

-   **Eviction strategy** - could purge LRU (least recently used)
-   **Sharding strategy** - can use a hash and mod system to figure out what machine in the pool to use

Load balancing: could have multiple web servers load balanced. DBMS should already be good at handling multiple connections at once.

## Conclusion

We have a system that fits our design goals:

1. Can store lots of links (database)
2. Shortlinks are as short as possible (many unique digits)
3. Following a shortlink is fast (fast NoSQL DB)
4. Resiliant to load spikes (load balancer)
